#!/bin/bash

#  Description:
#
# Simple tool to patch ubuntu/grub.cfg in EFI partition
# to mitigate the hardcoded grub.cfg path in Ubuntu
# Run the script with parameters to get help.
#

###############
# global vars #
###############
SOURCE_CFG="/boot/efi/EFI/lliurex-23/grub.cfg"
SOURCE_CFG=/tmp/grub.cfg
FSTAB_FILE="/etc/fstab"
BEGIN_SECTION="## BEGIN LLIUREX CHBOOT data ##"
END_SECTION="## END LLIUREX CHBOOT data ##"
CHBOOT_LABEL="chboot"
CHBOOT_MOUNT="/chboot"
CHBOOT_BASEDIR="/lliurex-chboot"
CHBOOT_FS="ext4"
CHBOOT_TAG="/etc/lliurex-auto-upgrade/tags/chboot"
CHBOOT_UUID=""
CHBOOT_PART=""

CHBOOT_ENTRY_FILES="control"
CHBOOT_ENTRY_SCRIPTS="prepare status mkgrub"

EFI_LLIUREX="lliurex-25 lliurex-23"
EFI_UBUNTU="ubuntu"
EFI_MOUNT="/boot/efi"
EFI_BASE="EFI"
EFI_PREFIX="chboot_"
CHBOOT_SOURCEDIR="/usr/share/lliurex-chboot/boot"
CHBOOT_ISODIR="$CHBOOT_BASEDIR/isos"
CHBOOT_IMGDIR="$CHBOOT_BASEDIR/imgs"
CHBOOT_BOOTDIR="$CHBOOT_BASEDIR/boot"

CHBOOT_DIRS="$CHBOOT_ISODIR $CHBOOT_IMGDIR $CHBOOT_BOOTDIR"

#############
# functions #
#############
die(){
        TYPE="ERROR"
        if [ "$#" -gt 1 ] ; then
                TYPE="$1"
                shift
        fi
        printf "${TYPE}: " >&2
        while [ "$1" ] ; do
                echo "$1" >&2
                shift
        done
        echo "" >&2

        exit 1
}

usage(){
	die "Usage" "$(basename "$0") {configure|unconfigure|mount|umount|list}" \
	    "       $(basename "$0") prepare CHBOOT_ENTRY [PREPARE_OPTIONAL_PARAMETERS ...]" \
	    "       $(basename "$0") boot-next CHBOOT_ENTRY" \
	    "       $(basename "$0") boot [+SECONDS] CHBOOT_ENTRY"
}

main(){
	[ "$1" ] || usage
	ACTION="$1"
	case "$ACTION" in
		configure)
			if ! chboot_configure ; then
				chboot_unconfigure
				die "CHBOOT partition not configured, aborting ..."
			fi
			;;
		unconfigure)
			chboot_unconfigure
			;;
		mount)
			chboot_mount -q
			;;
		umount)
			chboot_umount
			;;
		grub-fix)
			grub_add_patch || die "EFI partition is not mounted, aborting ..."
			;;
		grub-clean)
			grub_del_patch
			;;
		grub-status)
			rc=0
			grub_test_patch || rc=$?
			if [ $rc -eq 0 ] ; then
				echo "ON"
			else
				echo "OFF"
			fi
			exit $rc
			;;
		*)
			usage
			;;
	esac
}

file_test_patch(){
	FILE="$1"
	if grep -q  "^${BEGIN_SECTION}$" "$SOURCE_CFG" && grep -q "^${END_SECTION}$" "$FILE" ; then
		return 0
	fi
	return 1
}

file_del_patch(){
	FILE="$1"
	sed -i -e "/^${BEGIN_SECTION}$/,/^${END_SECTION}$/d" "$FILE"
}

chboot_test_partition(){
	chboot_get_uuid >/dev/null 2>/dev/null || return 1
	return 0
}

chboot_configure(){
	if chboot_test_partition ; then
		chboot_tag_set
		mkdir -p $CHBOOT_MOUNT
		ALREADY_MOUNTED="$(chboot_mount)"
		chboot_test_mount || return 1
		chboot_mkdirs || return 1
		chboot_update_entries || return 1
		[ "$ALREADY_MOUNTED" = "Y" ] || chboot_umount || true
		return 0
	fi
	return 1
}

chboot_unconfigure(){
	chboot_test_partition || chboot_tag_unset
	chboot_umount
	rmdir --ignore-fail-on-non-empty $CHBOOT_MOUNT >/dev/null 2>/dev/null || true
	grub_del_patch
}

chboot_update_entries(){
	for d in $(ls -1 $CHBOOT_SOURCEDIR) ; do
		if entry_validate "$d" ; then
			D="$CHBOOT_SOURCEDIR/$d"
			cp -r "$D"  "$CHBOOT_MOUNT/$CHBOOT_BOOTDIR"
			GRUB_DIR="$CHBOOT_MOUNT/$CHBOOT_BOOTDIR/$d/grub"
			mkdir -p "$GRUB_DIR"
			entry_run_script "$d" mkgrub > $GRUB_DIR/grub.cfg
		fi
	done
}

chboot_mkdirs(){
	for d in $CHBOOT_DIRS ; do
		mkdir -p "$CHBOOT_MOUNT/$d"
	done
	return 0
}

chboot_tag_set(){
	touch "$CHBOOT_TAG"
}

chboot_tag_unset(){
	rm -f "$CHBOOT_TAG"
}

chhboot_umount(){
	# do lazy umount 
	# umount -l $CHBOOT_MOUNT >/dev/null 2>/dev/null || true
	systemctl stop chboot.mount
}


chboot_update_vars(){
        CHBOOT_UUID="$(chboot_get_uuid)"
	CHBOOT_PART="$(chboot_get_part)"
}

chboot_get_uuid(){
	# chboot partition MUST HAVE chboot label
	CHBOOT_UUID="$(lsblk -plo LABEL,NAME,UUID |tr -s "[[:blank:]]" |sed -ne "/^$CHBOOT_LABEL\s/{s%^.*\s%%;p}")"
	[ "$CHBOOT_UUID" ] || return 1
	#die "CHBOOT partition not found, aborting ..."
	echo "$CHBOOT_UUID"
	return 0
}

chboot_get_part(){
	# chboot partition MUST HAVE chboot label
	CHBOOT_PART="$(lsblk -plo LABEL,NAME |tr -s "[[:blank:]]" |sed -ne "/^$CHBOOT_LABEL\s/{s%^.*\s%%;p}")"
	[ "$CHBOOT_PART" ] || return 1
	echo "$CHBOOT_PART"
	return 0
}

chboot_test_mount(){
	if df --output=target,source $CHBOOT_MOUNT |grep -q "^$CHBOOT_MOUNT" ; then
		return 0
	fi
	return 1
}

chboot_mount(){
	if chboot_test_mount ; then
		[ "$1" = "-q" ] || echo "Y"
		return 0
	fi
	[ "$1" = "-q" ] || echo "N"
	systemctl start chboot.mount
	if chboot_test_mount ; then
		return 0
	fi
	return 1
}

entry_show_field(){
	ENTRY_NAME="$1"
	ALREADY_MOUNTED="$(chboot_mount)"
	chboot_test_mount || return 1
	#CHBOOT_PATH="$CHBOOT_MOUNT/$ENTRY_NAME"
	CHBOOT_PATH="$CHBOOT_MOUNT/$CHBOOT_BOOTDIR/$ENTRY_NAME"
	# TODO: read field ....
	
	[ "$ALREADY_MOUNTED" = "Y" ] || chboot_umount || true
}

entry_add(){
	# TODO: write this ....
	entry_add_grub || return 1

	return 0
}

entry_run_script(){
	ENTRY_NAME="$1"
	SCRIPT_NAME="$2"
	SCRIPT="$CHBOOT_MOUNT/$CHBOOT_BOOTDIR/$ENTRY_NAME/scripts/$SCRIPT_NAME"
	ALREADY_MOUNTED="$(chboot_mount)"
	if [ -x "$SCRIPT" ] ; then
		chboot_update_vars
		export CHBOOT_LABEL CHBOOT_MOUNT CHBOOT_BASEDIR CHBOOT_FS CHBOOT_TAG CHBOOT_UUID CHBOOT_PART CHBOOT_SOURCEDIR CHBOOT_ISODIR CHBOOT_IMGDIR CHBOOT_BOOTDIR
		rc=0
		$SCRIPT || rc=$?
		return $rc
	else
		rc=1
	fi
	[ "$ALREADY_MOUNTED" = "Y" ] || chboot_umount || true
	return $rc
}

get_diskname(){
	echo "$1" |sed -e "s%[[:digit:]]*$%%"
}

get_partnum(){
	echo "$1" |sed -e "s%^[^[:digit:]]*%%"
}

entry_validate(){
	ENTRY_DIR="$CHBOOT_SOURCEDIR/$1"
	for f in $CHBOOT_ENTRY_FILES ; do
		[ -r "$ENTRY_DIR/$f" ] || return 1
	done
	for f in $CHBOOT_ENTRY_SCRIPTS ; do
		[ -x "$ENTRY_DIR/scripts/$f" ] || return 1
	done
	return 0
}

entry_add_chboot(){
#	ENTRY_NAME="${EFI_PREFIX}${1}"
	ENTRY_NAME="$1"
	ALREADY_MOUNTED="$(chboot_mount)"
	chboot_test_mount || return 1
	#CHBOOT_PATH="$CHBOOT_MOUNT/$ENTRY_NAME"
	CHBOOT_PATH="$CHBOOT_MOUNT/$CHBOOT_BOOTDIR/$ENTRY_NAME"
	mkdir -p "$CHBOOT_PATH/grub"
	# TODO: terminate ...

	[ "$ALREADY_MOUNTED" = "Y" ] || chboot_umount || true
}

entry_get_bootnum(){
	ENTRY_NAME="${EFI_PREFIX}${1}"
	efibootmgr |sed -ne "/${ENTRY_NAME}$/{s%^Boot%%;s%\*\{0,1\}\s\+.*$%%;p}"
}

entry_del_efi(){
	BOOT_NUM="$(entry_get_bootnum "$1")"
	if echo "$BOOT_NUM" |grep -q "^[[:digit:]]\+$" ; then
		efibootmgr -B -b $BOOT_NUM  >/dev/null 2>/dev/null
	fi
}

entry_set_bootnext(){
	BOOT_NUM="$(entry_get_bootnum "$1")"
	if echo "$BOOT_NUM" |grep -q "^[[:digit:]]\+$" ; then
		efibootmgr -n $BOOT_NUM  >/dev/null 2>/dev/null
	fi
}

entry_unset_bootnext(){
	if echo "$BOOT_NUM" |grep -q "^[[:digit:]]\+$" ; then
		efibootmgr -N  >/dev/null 2>/dev/null
	fi
}

entry_add_efi(){
	ENTRY_NAME="${EFI_PREFIX}${1}"
	CHBOOT_UUID="$(chboot_get_uuid)"
	[ "$CHBOOT_UUID" ] || return 1
	ENTRY_PATH="$EFI_MOUNT/$EFI_BASE/$ENTRY_NAME"
	if [ ! -d "$ENTRY_PATH" ] ; then
		# check for lliurex dir or use ubuntu as default
		TEMPLATE_PATH=""
		for d in  $EFI_LLIUREX $EFI_UBUNTU ; do
			D="$EFI_MOUNT/$EFI_BASE/$d"
			if [ -z "$TEMPLATE_PATH" ] && [ -d "$D" ]  ; then
				TEMPLATE_PATH="$D"
			fi
		done
		[ "$TEMPLATE_PATH" ] || return 1
		cp -r "$TEMPLATE_PATH" "$ENTRY_PATH"
	fi

	# create grub prefix configuration in EFI partition
	EFI_CFG="$ENTRY_PATH/grub.cfg"
	cat << EOF > "$EFI_CFG"
search.fs_uuid $CHBOOT_UUID  root hd0,gpt2
set prefix=($root)'/$ENTRY_NAME/boot/grub'
configfile $prefix/grub.cfg
EOF
	# delete boot entry 
	entry_del_efi "$1"

	# create boot entry 
	EFI_PART="$(efi_get_part)"
	efibootmgr  --create-only --disk=$(get_diskname "$EFI_PART") --part=$(get_partnum "$EFI_PART") --label="$ENTRY_NAME" --loader='\EFI\$ENTRY_NAME\shimx64.efi'
	return 0
}

entry_del_grub(){
	ENTRY_NAME="${EFI_PREFIX}${1}"
	ENTRY_PATH="$EFI_MOUNT/$EFI_BASE/$ENTRY_NAME"
	if [ -d "$ENTRY_PATH" ] ; then
		rm -rf "$ENTRY_PATH"
	fi
}

efi_get_part(){
	# try with df (if mounted)
	read t s f < <(df --output=target,source,fstype |grep "^$EFI_MOUNT" |tr -s "[[:blank:]]")
	if [ "$t" = "$EFI_MOUNT" ] || echo "$f" |grep -iq "fat" ; then
		EFI_PART="$s"
	else
		# there is an alternative:  try to get first fat partition:

		# read f s < <(lsblk -plo FSTYPE,NAME |grep -i "^v\{0,1\}fat" |tr -s "[[:blank:]]" |head -1)
		# EFI_PART="$s"

		# but, in Ubuntu EFI partitione MUST BE mounted ....
		return 1
	fi
	echo "$EFI_PART"
	return 0
}

efi_get_uuid(){
	EFI_UUID=""
	EFI_PART="$(efi_get_part)"
	if [ "$EFI_PART" ] ; then
		read s EFI_UUID < <(lsblk -plo NAME,UUID |grep "^$EFI_PART" |tr -s "[[:blank:]]")
	fi
	[ "$EFI_UUID" ] || return 1
	echo "$EFI_UUID"
	return 0
}

grub_clean(){
	grub_del_patch
}

grub_do_backup() {
	cp "$SOURCE_CFG" "${SOURCE_CFG}.backup"
}

grub_test_patch(){
	if file_test_patch "$SOURCE_CFG" ; then
		return 0
	fi
	return 1
}

grub_del_patch(){
	file_del_patch "$SOURCE_CFG"
}

grub_add_patch(){
	EFI_UUID="$(efi_get_uuid)"
	[ "$EFI_UUID" ] || return 1
	grub_del_patch
	grub_do_backup
	TMP_FILE="$(mktemp)"
	cat <<EOF > "$TMP_FILE"
$BEGIN_SECTION
# get EFI partition
search.fs_uuid $EFI_UUID rootEFI hd0,gpt1
# use cmdpath environment variable to guess the required EFI grub configuration to run
if [ -n "\$cmdpath" ] ; then
	if [ "\$cmdpath" != "(\$rootEFI)/EFI/ubuntu" ] ; then
		if [ -e "\$cmdpath/grub.cfg" ] ; then
			# jump to UEFI expected grub.cfg
        		configfile \$cmdpath/grub.cfg
		fi
	fi
fi

# continue with default ubuntu grub sequence
$END_SECTION
EOF
	cat "$SOURCE_CFG" >> "$TMP_FILE"
	cat "$TMP_FILE" > "$SOURCE_CFG"
	rm -f "$TMP_FILE"
}


################
# main program #
################
main "$@"
exit 0


